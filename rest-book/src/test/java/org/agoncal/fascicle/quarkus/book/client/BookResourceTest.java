package org.agoncal.fascicle.quarkus.book.client;

import static org.junit.Assert.assertTrue;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.math.BigDecimal;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.List;

import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;

import org.agoncal.fascicle.quarkus.book.Database;
import org.agoncal.fascicle.quarkus.book.data.Book;
import org.hamcrest.core.Is;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.restassured.RestAssured;
import io.restassured.common.mapper.TypeRef;

@QuarkusTest
@QuarkusTestResource(Database.class)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class BookResourceTest {

	private static final String DEFAULT_TITLE = "Title";
	private static final String UPDATED_TITLE = "Title (updated)";
	private static final String DEFAULT_AUTHOR = "Author";
	private static final String UPDATED_AUTHOR = "Author (updated)";
	private static final Integer DEFAULT_YEAR_OF_PUBLICATION = 1111;
	private static final Integer UPDATED_YEAR_OF_PUBLICATION = 2222;
	private static final Integer DEFAULT_NB_OF_PAGES = 111;
	private static final Integer UPDATED_NB_OF_PAGES = 222;
	private static final Integer DEFAULT_RANK = 1;
	private static final Integer UPDATED_RANK = 2;
	private static final BigDecimal DEFAULT_PRICE = new BigDecimal(11.0);
	private static final BigDecimal UPDATED_PRICE = new BigDecimal(22.0);
	private static final URL DEFAULT_SMALL_IMAGE_URL = makeUrl("http://www.url.com");
	private static final URL UPDATED_SMALL_IMAGE_URL = makeUrl("http://www.updatedurl.com");
	private static final URL DEFAULT_MEDIUM_IMAGE_URL = makeUrl("http://www.url.com");
	private static final URL UPDATED_MEDIUM_IMAGE_URL = makeUrl("http://www.updatedurl.com");
	private static final String DEFAULT_DESCRIPTION = "Description";
	private static final String UPDATED_DESCRIPTION = "Description (updated)";

	// Mocking numbers that should be generated by the Number microservice
	public static final String MOCK_ISBN_13 = "Isbn 13";
	public static final String MOCK_ISBN_10 = "Isbn 10";
	private static URL makeUrl(String urlString) {
		try {
			return new URL(urlString);
		} catch (MalformedURLException e) {
			return null;
		}
	}
	private static int nbBooks;
	private static String bookId;

	@Test
	@Order(1)
	public void shouldGetInitialItems() {
		List<Book> books = RestAssured.given()
				.when()
				.get("/api/books")
				.then()
				.statusCode(Status.OK.getStatusCode())
				.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
				.extract().body().as(getBookTypeRef());

		nbBooks = books.size();
	}

	@Test
	@Order(2)
	public void shouldAddAnItem() {
		Book book = new Book();
		book.title = DEFAULT_TITLE;
		book.author = DEFAULT_AUTHOR;
		book.yearOfPublication = DEFAULT_YEAR_OF_PUBLICATION;
		book.nbOfPages = DEFAULT_NB_OF_PAGES;
		book.rank = DEFAULT_RANK;
		book.price = DEFAULT_PRICE;
		book.isbn10 = MOCK_ISBN_10;
		book.isbn13 = MOCK_ISBN_13;
		book.smallImageUrl = DEFAULT_SMALL_IMAGE_URL;
		book.mediumImageUrl = DEFAULT_MEDIUM_IMAGE_URL;
		book.description = DEFAULT_DESCRIPTION;

		// Persist a new book
		String location = RestAssured.given()
				.body(book)
				.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
				.header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON)
				.when()
				.post("/api/books")
				.then()
				.statusCode(Status.CREATED.getStatusCode())
				.extract().header("Location");

		// Extracts the location and stores the book id
		assertTrue(location.contains("/api/books"));
		String[] segments = location.split("/");
		bookId = segments[segments.length - 1];

		// checks the book has been created
		RestAssured.given()
		.pathParam("id", bookId)
		.when()
		.get("/api/books/{id}")
		.then()
		.statusCode(Status.OK.getStatusCode())
		.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
		.body("title", Is.is(DEFAULT_TITLE))
		.body("isbn13", Is.is(MOCK_ISBN_13))
		.body("isbn10", Is.is(MOCK_ISBN_10))
		.body("author", Is.is(DEFAULT_AUTHOR))
		.body("yearOfPublication", Is.is(DEFAULT_YEAR_OF_PUBLICATION))
		.body("nbOfPages", Is.is(DEFAULT_NB_OF_PAGES))
		.body("rank", Is.is(DEFAULT_RANK))
		.body("smallImageUrl", Is.is(DEFAULT_SMALL_IMAGE_URL.toString()))
		.body("mediumImageUrl", Is.is(DEFAULT_MEDIUM_IMAGE_URL.toString()))
		.body("description", Is.is(DEFAULT_DESCRIPTION));

		// checks there is an extra book in the database
		List<Book> books = RestAssured.given()
				.when()
				.get("/api/books")
				.then()
				.statusCode(Status.OK.getStatusCode())
				.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
				.extract().body().as(getBookTypeRef());
		
		assertEquals(nbBooks + 1, books.size());
	}

	@Test
	@Order(3)
	void shouldUpdateAnItem() {
		Book book = new Book();
		book.id = Long.valueOf(bookId);
		book.title = UPDATED_TITLE;
		book.isbn13 = MOCK_ISBN_13;
		book.isbn10 = MOCK_ISBN_10;
		book.author = UPDATED_AUTHOR;
		book.yearOfPublication = UPDATED_YEAR_OF_PUBLICATION;
		book.nbOfPages = UPDATED_NB_OF_PAGES;
		book.rank = UPDATED_RANK;
		book.price = UPDATED_PRICE;
		book.smallImageUrl = UPDATED_SMALL_IMAGE_URL;
		book.mediumImageUrl = UPDATED_MEDIUM_IMAGE_URL;
		book.description = UPDATED_DESCRIPTION;
		// Updates the previously created book
		RestAssured.given()
			  .body(book)
			  .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
			  .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON)
			  .when()
			  .put("/api/books")
			  .then()
			  .statusCode(Status.OK.getStatusCode())
			  .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
			  .body("title", Is.is(UPDATED_TITLE))
			  .body("isbn13", Is.is(MOCK_ISBN_13))
			  .body("isbn10", Is.is(MOCK_ISBN_10))
			  .body("author", Is.is(UPDATED_AUTHOR))
			  .body("yearOfPublication", Is.is(UPDATED_YEAR_OF_PUBLICATION))
			  .body("nbOfPages", Is.is(UPDATED_NB_OF_PAGES))
			  .body("rank", Is.is(UPDATED_RANK))
			  .body("price", Is.is(UPDATED_PRICE.intValue()))
			  .body("smallImageUrl", Is.is(UPDATED_SMALL_IMAGE_URL.toString()))
			  .body("mediumImageUrl", Is.is(UPDATED_MEDIUM_IMAGE_URL.toString()))
			  .body("description", Is.is(UPDATED_DESCRIPTION));
	}
	
	@Test
	@Order(4)
	public void shouldRemoveAnItem() {
		// deletes the previously created book
		RestAssured.given()
			  .pathParam("id", bookId)
			  .when()
			  .delete("/api/books/{id}")
			  .then()
			  .statusCode(Status.NO_CONTENT.getStatusCode());
		
		// checks there is less a book 
		List<Book> books = RestAssured.given()
								 .when()
								 .get("/api/books")
								 .then()
								 .statusCode(Status.OK.getStatusCode())
								 .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
								 .extract().body().as(getBookTypeRef());
		
		assertEquals(nbBooks, books.size());
	}
	
	@Test
	public void shouldNotAddInvalidItem() {
		Book book = new Book();
		book.title = null;
		
		RestAssured.given()
			 .body(book)
			 .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
			 .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON)
			 .when()
			 .post("/api/books")
			 .then()
			 .statusCode(Status.BAD_REQUEST.getStatusCode());
	}
	
	private TypeRef<List<Book>> getBookTypeRef() {
		return new TypeRef<List<Book>>() {};
	}
}
